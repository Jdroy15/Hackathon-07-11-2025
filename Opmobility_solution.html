<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LFSR-Plus Probe Auth — GUI Prototype</title>
<style>
body {font-family: Inter, Roboto, Arial, sans-serif; margin: 16px; background:#f7f8fb; color:#111; transition: background 0.3s, color 0.3s;}
body.dark {background:#1a1a1a; color:#eee;}
.container{max-width:1200px;margin:0 auto;}
header{display:flex;align-items:center;gap:12px;flex-wrap:wrap;}
h1{font-size:20px;margin:0;}
.controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px;}
.card{background:white;border-radius:8px;padding:12px;box-shadow:0 6px 18px rgba(20,20,50,0.06);transition:background 0.3s, color 0.3s;}
body.dark .card{background:#2c2c2c; color:#eee;}
label{display:block;font-size:12px;color:#333;margin-bottom:6px;}
body.dark label{color:#ccc;}
input[type=number], input[type=text], select{width:120px;padding:6px;border-radius:6px;border:1px solid #ddd;}
body.dark input, body.dark select{background:#444;color:#eee;border:1px solid #666;}
button{padding:8px 12px;border-radius:6px;border:0;background:#2b7cff;color:white;cursor:pointer;}
button.secondary{background:#6c757d;}
#canvasRow{display:flex;gap:12px;margin-top:14px;flex-wrap:wrap;}
canvas{background:#fff;border-radius:8px;box-shadow:0 6px 18px rgba(20,20,50,0.04);}
body.dark canvas{background:#222;}
.col{flex:1; min-width:280px;}
.log{height:180px;overflow:auto;font-family:monospace;font-size:13px;padding:8px;background:#0f1720;color:#e2e8f0;border-radius:6px;}
.small{font-size:12px;color:#555;}
body.dark .small{color:#aaa;}
footer{margin-top:14px;font-size:12px;color:#666;}
body.dark footer{color:#bbb;}
.controls .card.small{padding:8px;}
.hint{font-size:12px;color:#666;margin-top:6px;}
body.dark .hint{color:#aaa;}
@media(max-width:800px){#canvasRow{flex-direction:column;}}
</style>
</head>
<body>
<div class="container">
<header>
  <div class="card" style="padding:8px 12px;display:flex;align-items:center;gap:10px">
    <svg width="36" height="36" viewBox="0 0 24 24"><path fill="#2b7cff" d="M12 2L2 7v6c0 5 5 9 10 9s10-4 10-9V7l-10-5z"></path></svg>
    <div>
      <h1>LFSR-Plus Probe Auth — GUI Prototype</h1>
      <div class="small">Interactive demo: configure seeds, window, inject attacks, export logs, record animation video.</div>
    </div>
  </div>
</header>

<div class="controls">
  <div class="card small">
    <label>Probe Seed (hex)</label>
    <input id="probeSeed" type="text" value="ACE1" />
  </div>
  <div class="card small">
    <label>ECU Seed (hex)</label>
    <input id="ecuSeed" type="text" value="ACE1" />
    <div class="hint">Make these different to simulate provisioning errors.</div>
  </div>
  <div class="card small">
    <label>Messages to send</label>
    <input id="msgCount" type="number" value="20" min="1" max="500" />
  </div>
  <div class="card small">
    <label>Sliding window (W)</label>
    <input id="window" type="number" value="4" min="0" max="64" />
  </div>
  <div class="card small">
    <label>Fail threshold (lockout)</label>
    <input id="failThreshold" type="number" value="6" min="1" max="50" />
  </div>
  <div class="card small">
    <label>Message data size (bytes)</label>
    <select id="dataSize"><option value="1">1</option><option value="2">2</option><option value="4">4</option></select>
  </div>
  <div class="card small">
    <label>Inject corruption at message #</label>
    <input id="corruptAt" type="number" value="8" min="1" />
  </div>
  <div class="card small">
    <label>Replay recorded frame at message #</label>
    <input id="replayAt" type="number" value="12" min="1" />
  </div>
  <div class="card small" style="display:flex;flex-direction:column;gap:8px;justify-content:center">
    <button id="runBtn">Run Simulation</button>
    <button id="playAnim" class="secondary">Play Animation</button>
    <button id="recordBtn" class="secondary">Record Video</button>
    <button id="exportCSV" class="secondary">Export CSV</button>
    <button id="toggleMode" class="secondary">Toggle Dark/Light</button>
  </div>
</div>

<div id="canvasRow">
  <div class="col card" style="padding:8px">
    <canvas id="timeline" width="900" height="220"></canvas>
    <div class="hint">Animation shows probe (left) sending frames to ECU (right). Green=accept, red=reject. Replay-rejected=orange.</div>
  </div>
  <div class="col card" style="padding:8px;max-width:420px">
    <canvas id="keystream" width="420" height="220"></canvas>
    <div class="hint">Keystream bytes (k1,k2). Useful to show rolling secret.</div>
  </div>
</div>

<div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
  <div class="card" style="flex:1">
    <div style="font-weight:600;margin-bottom:8px">Console / Log</div>
    <div id="log" class="log">Ready. Configure options and press Run Simulation.</div>
  </div>
  <div class="card" style="width:260px">
    <div style="font-weight:600;margin-bottom:8px">Suggested features</div>
    <div class="small">• Export CSV of each frame<br>• Record animation video (WebM)<br>• Toggle probe vs ECU seeds<br>• Add CAN ID and packet inspector<br>• Add challenge-response/resync button<br>• Integrate python-can / SocketCAN example</div>
  </div>
</div>
<footer>Prototype for visual explanation — works offline in browser.</footer>
</div>

<script>
// ----- Utilities -----
function parseHex(s){ try{ return parseInt(s.trim(),16)&0xFFFF; } catch(e){ return 0xACE1; } }
function lfsrNextByte(state){
  let s = state & 0xFFFF; let out=0;
  for(let i=0;i<8;i++){
    let lsb=s&1; s=s>>>1; if(lsb) s^=0xB400;
    out=((out<<1)|lsb)&0xFF;
  }
  return {state:s&0xFFFF, byte:out};
}
const SBOX=[6,15,3,8,10,1,7,13,9,0,11,4,14,2,12,5];
function sboxByte(v){ let hi=(v>>4)&0xF, lo=v&0xF; return ((SBOX[hi]<<4)|SBOX[lo])&0xFF; }
function tinyMix(dataBytes, ctr, k1, k2){
  let x=0; for(let b of dataBytes)x=(x+b)&0xFF;
  let a=x^k1, b2=((x+ctr)&0xFF)^k2;
  let t0=sboxByte(a), t1=sboxByte(b2);
  t0=((t0<<3)|(t0>>5))&0xFF; t1=((t1<<5)|(t1>>3))&0xFF;
  return ((t0<<8)|t1)&0xFFFF;
}

// ----- Drawing -----
function clearCanvas(c){ c.getContext('2d').clearRect(0,0,c.width,c.height); }
function drawTimelineStatic(canvas, results){
  const ctx=canvas.getContext('2d'); const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  const left=40, right=10, top=20, bottom=30, innerW=w-left-right, innerH=h-top-bottom;
  ctx.strokeStyle='#ddd'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(left,top); ctx.lineTo(left,top+innerH); ctx.stroke();
  ctx.font='12px monospace'; ctx.fillStyle='#333';
  ctx.fillText('ACCEPT',6,top+12); ctx.fillText('REJECT',6,top+innerH-6); ctx.fillText('REPLAY-REJECT',6,top+innerH/2,'#ff8800');
  
  results.forEach((r,i)=>{
    const x=left+(i/(Math.max(1,results.length-1)))*innerW;
    let y=r.verified?(top+14):(r.replayRejected?(top+innerH/2):top+innerH-14);
    let color=r.verified?'#1da654':r.replayRejected?'#ff8800':'#e35a5a';
    ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fillStyle=color; ctx.fill();
    ctx.fillStyle='#222'; ctx.font='10px monospace'; ctx.textAlign='center';
    ctx.fillText('T='+r.tag.toString(16).padStart(4,'0').toUpperCase(), x, r.verified?y-10:y+22);
    if(r.attack){ ctx.fillText(r.attack.toUpperCase(), x, top+innerH+14); }
  });
}
function drawKeystream(canvas, results){
  const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
  const w=canvas.width,h=canvas.height,left=40,top=10,innerW=w-left-10,innerH=h-top-30;
  const n=results.length;
  const maxv=255;
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle='#eee'; for(let y=0;y<=4;y++){ let yy=top+(y/4)*innerH; ctx.beginPath(); ctx.moveTo(left,yy); ctx.lineTo(left+innerW,yy); ctx.stroke(); }
  function plot(arr,style){ ctx.beginPath(); for(let i=0;i<n;i++){ let x=left+(i/(Math.max(1,n-1)))*innerW; let y=top+innerH-(arr[i]/maxv)*innerH; if(i==0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.lineWidth=2; ctx.strokeStyle=style; ctx.stroke(); for(let i=0;i<n;i++){ let x=left+(i/(Math.max(1,n-1)))*innerW; let y=top+innerH-(arr[i]/maxv)*innerH; ctx.fillStyle=style; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();}}
  plot(results.map(r=>r.k1),'#f6b042'); plot(results.map(r=>r.k2),'#4aa3ff'); ctx.fillStyle='#222'; ctx.font='11px sans-serif'; ctx.fillText('k1',left+6,top+12); ctx.fillText('k2',left+40,top+12);
}

// ----- Simulation -----
let lastResults=[], lastAcceptedCtr=-1, recordedFrame=null;
function simulateFlow(){
  const probeSeed=parseHex(document.getElementById('probeSeed').value||'ACE1');
  const ecuSeed=parseHex(document.getElementById('ecuSeed').value||'ACE1');
  const count=parseInt(document.getElementById('msgCount').value)||20;
  const W=parseInt(document.getElementById('window').value)||4;
  const failThreshold=parseInt(document.getElementById('failThreshold').value)||6;
  const dataSize=parseInt(document.getElementById('dataSize').value)||1;
  const corruptAt=parseInt(document.getElementById('corruptAt').value)||-1;
  const replayAt=parseInt(document.getElementById('replayAt').value)||-1;

  let probeState=probeSeed&0xFFFF, ecuState=ecuSeed&0xFFFF, failCount=0;
  lastAcceptedCtr=-1; recordedFrame=null;
  let results=[];

  for(let i=0;i<count;i++){
    const ctr=(i+1)&0xFF; const dataBytes=[]; for(let b=0;b<dataSize;b++){ dataBytes.push((50+(i%5)+b)&0xFF); }
    let res=lfsrNextByte(probeState); probeState=res.state; const k1=res.byte;
    res=lfsrNextByte(probeState); probeState=res.state; const k2=res.byte;
    const tag=tinyMix(dataBytes,ctr,k1,k2);
    let message={ctr,data:dataBytes.slice(),tag,k1,k2,orig:i+1};
    let toVerify=message, attack=null, replayRejected=false;

    // handle corruption and replay
    if(i===corruptAt-1){ attack='corruption'; toVerify={...message, tag: (tag^0xFFFF)&0xFFFF}; }
    else if(i===replayAt-1 && recordedFrame){ attack='replay'; toVerify=recordedFrame; }

    if(i===corruptAt-1 || (i===replayAt-1 && recordedFrame)){ recordedFrame=message; } // store first valid frame

    // ECU verification
    let verified=false, matchedStep=null, newEcuState=ecuState;
    for(let step=0;step<=W;step++){
      let s=ecuState; for(let t=0;t<step;t++){ s=lfsrNextByte(s).state; }
      let r=lfsrNextByte(s); let vk1=r.byte; s=r.state;
      r=lfsrNextByte(s); let vk2=r.byte; s=r.state;
      let expected=tinyMix(toVerify.data,toVerify.ctr,vk1,vk2);
      if(expected===toVerify.tag){ verified=true; matchedStep=step; newEcuState=s; break; }
    }

    // Anti-replay: reject if CTR ≤ lastAcceptedCtr
    if(verified && toVerify.ctr<=lastAcceptedCtr){ verified=false; replayRejected=true; attack='replay-counter'; }
    if(verified){ ecuState=newEcuState; failCount=0; lastAcceptedCtr=Math.max(lastAcceptedCtr,toVerify.ctr); }
    else failCount++;

    results.push({...toVerify, verified, attack, replayRejected, matchedStep});
  }

  lastResults=results;
  const log=document.getElementById('log'); log.textContent='';
  results.forEach(r=>{
    log.textContent+=`Msg ${r.orig}: CTR=${r.ctr} DATA=[${r.data}] TAG=0x${r.tag.toString(16).padStart(4,'0').toUpperCase()} => ${r.verified?'ACCEPT':r.replayRejected?'REJECT(REPLAY)':'REJECT'}${r.attack?' ('+r.attack+')':''}\n`;
  });

  drawTimelineStatic(document.getElementById('timeline'), results);
  drawKeystream(document.getElementById('keystream'), results);
  return results;
}

// ----- Animation -----
let animPlaying=false;
function playAnimation(results, pace=600){
  if(!results||results.length===0) return;
  const canvas=document.getElementById('timeline'); const ctx=canvas.getContext('2d');
  animPlaying=true; const left=40,right=10,top=20,bottom=30,innerW=canvas.width-left-right,innerH=canvas.height-top-bottom;
  let idx=0;
  function step(){ if(idx>=results.length){ animPlaying=false; return; }
    drawTimelineStatic(canvas, results);
    const r=results[idx]; const xStart=left; const xEnd=left+(idx/(Math.max(1,results.length-1)))*innerW;
    let f=0, frames=20;
    function frameLoop(){ if(f>frames){ idx++; if(idx<results.length)setTimeout(step,pace); else animPlaying=false; return; }
      const t=f/frames; const x=xStart+(xEnd-xStart)*t; const y=top+innerH/2;
      ctx.beginPath(); ctx.fillStyle='rgba(43,124,255,0.9)'; ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
      f++; requestAnimationFrame(frameLoop);
    } frameLoop();
  } step();
}

// ----- CSV export -----
function exportCSV(results){
  if(!results || results.length===0) return alert('Run simulation first');
  let csv='msg,ctr,data,tag,k1,k2,verified,attack,matchedStep\n';
  results.forEach(r=>{
    csv+=`${r.orig},${r.ctr},"${r.data}",${r.tag},${r.k1},${r.k2},${r.verified},${r.attack||''},${r.matchedStep||''}\n`;
  });
  const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='lfsr_sim_log.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

// ----- Event hookups -----
document.addEventListener('DOMContentLoaded',()=>{
  document.getElementById('runBtn').addEventListener('click',simulateFlow);
  document.getElementById('playAnim').addEventListener('click',()=>{ if(lastResults.length===0) lastResults=simulateFlow(); playAnimation(lastResults); });
  document.getElementById('exportCSV').addEventListener('click',()=>exportCSV(lastResults));
  document.getElementById('toggleMode').addEventListener('click',()=>document.body.classList.toggle('dark'));
});
</script>
</body>
</html>
